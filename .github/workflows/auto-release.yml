name: Auto Pre-release and Docker Tag

on:
  push:
    branches: [ develop, main ]

permissions:
  contents: write
  packages: write

env:
  DOCKER_ENABLED: true  # Set to false if you don't want Docker CI/CD (configured via setup:starter-kit)
  REGISTRY: docker.io
  IMAGE_NAME: koamishin/koamistarterkit

jobs:
  optimize_ci:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.check_skip.outputs.skip }}
    steps:
      - name: Optimize CI
        id: check_skip
        uses: withgraphite/graphite-ci-action@main
        with:
          graphite_token: RZIHC9RcWuPOikTuveo3KetGbIBSctAWhkQ82qVW8cPmpn087Emx6VLq4uz8

  analyze-commit:
    runs-on: ubuntu-latest
    needs: optimize_ci
    if: github.actor != 'github-actions[bot]' && needs.optimize_ci.outputs.skip == 'false'
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_type: ${{ steps.version.outputs.release_type }}
      should_release: ${{ steps.version.outputs.should_release }}
      is_main: ${{ steps.version.outputs.is_main }}
      commit_message: ${{ steps.version.outputs.commit_message }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze commit and determine version
        id: version
        shell: bash
        run: |
          set -euo pipefail

          git fetch --tags --force

          # Get commit message (first line only)
          COMMIT_MSG=$(git log -1 --pretty=%B | head -n1)
          echo "Commit message: $COMMIT_MSG"
          {
            echo 'commit_message<<EOF'
            echo "$COMMIT_MSG"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          # Determine bump based on commit message
          if [[ "$COMMIT_MSG" =~ ^(feat|feature)[:\(] ]]; then
            RELEASE_TYPE="feature"
            BUMP="minor"
          elif [[ "$COMMIT_MSG" =~ ^(fix|bugfix)[:\(] ]]; then
            RELEASE_TYPE="bugfix"
            BUMP="patch"
          elif [[ "$COMMIT_MSG" =~ ^(break|major|breaking)[:\(] ]]; then
            RELEASE_TYPE="major"
            BUMP="major"
          elif [[ "$COMMIT_MSG" =~ ^(chore|docs|style|refactor|test)[:\(] ]]; then
            RELEASE_TYPE="chore"
            BUMP="patch"
          else
            RELEASE_TYPE="patch"
            BUMP="patch"
          fi

          echo "Release type: $RELEASE_TYPE"
          echo "Bump type: $BUMP"
          echo "release_type=$RELEASE_TYPE" >> "$GITHUB_OUTPUT"

          # Base version from latest *stable* semver tag (ignores prerelease tags)
          # We keep this version stable and only increment the dev suffix
          LATEST_STABLE_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1 || true)
          if [ -n "${LATEST_STABLE_TAG:-}" ]; then
            BASE_VERSION="${LATEST_STABLE_TAG#v}"
          else
            BASE_VERSION="1.0.0"
          fi

          echo "Base version (stable): $BASE_VERSION"

          # Dev releases use format: v{BASE}-dev.{MINOR}.{PATCH}
          # - Feature/Major commits: increment MINOR, reset PATCH to 0
          # - Patch/Fix/Chore commits: increment PATCH only
          PRERELEASE_PREFIX="dev"
          
          # Find the latest dev tag for this base version with format v{BASE}-dev.X.Y
          LATEST_DEV_TAG=$(git tag -l "v${BASE_VERSION}-${PRERELEASE_PREFIX}.*.*" --sort=-v:refname | head -n1 || true)
          
          if [ -n "${LATEST_DEV_TAG:-}" ]; then
            # Extract the dev minor and patch from the tag (e.g., v1.2.3-dev.2.5 -> 2 and 5)
            DEV_SUFFIX="${LATEST_DEV_TAG#v${BASE_VERSION}-${PRERELEASE_PREFIX}.}"
            DEV_MINOR=$(echo "$DEV_SUFFIX" | cut -d'.' -f1)
            DEV_PATCH=$(echo "$DEV_SUFFIX" | cut -d'.' -f2)
            
            # Validate we got numbers, default to 0 if not
            [[ "$DEV_MINOR" =~ ^[0-9]+$ ]] || DEV_MINOR=0
            [[ "$DEV_PATCH" =~ ^[0-9]+$ ]] || DEV_PATCH=0
          else
            # No existing dev tags, start at 0.0
            DEV_MINOR=0
            DEV_PATCH=0
          fi

          echo "Current dev version: ${DEV_MINOR}.${DEV_PATCH}"

          # Bump based on commit type
          case "$BUMP" in
            major|minor)
              # Feature/Major: increment dev minor, reset patch
              DEV_MINOR=$((DEV_MINOR + 1))
              DEV_PATCH=0
              ;;
            patch|*)
              # Patch/Fix/Chore: increment dev patch only
              DEV_PATCH=$((DEV_PATCH + 1))
              ;;
          esac

          TAG="v${BASE_VERSION}-${PRERELEASE_PREFIX}.${DEV_MINOR}.${DEV_PATCH}"
          
          # Ensure tag doesn't already exist (safety check)
          while git rev-parse "$TAG" >/dev/null 2>&1; do
            DEV_PATCH=$((DEV_PATCH + 1))
            TAG="v${BASE_VERSION}-${PRERELEASE_PREFIX}.${DEV_MINOR}.${DEV_PATCH}"
          done

          VERSION="${BASE_VERSION}-${PRERELEASE_PREFIX}.${DEV_MINOR}.${DEV_PATCH}"

          echo "Resolved prerelease tag: $TAG"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

          # This workflow runs on develop only
          echo "should_release=true" >> "$GITHUB_OUTPUT"
          echo "is_main=false" >> "$GITHUB_OUTPUT"

  build-and-push:
    runs-on: ubuntu-latest
    needs: analyze-commit
    if: always() && needs.analyze-commit.result == 'success'

    steps:
      - name: Check if Docker is enabled
        id: check_docker
        run: |
          if [ "${{ env.DOCKER_ENABLED }}" != "true" ]; then
            echo "Docker CI/CD is disabled. Skipping Docker build."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        if: steps.check_docker.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check_docker.outputs.skip != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: steps.check_docker.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        if: steps.check_docker.outputs.skip != 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.analyze-commit.outputs.tag }}
            type=raw,value=dev-latest
            type=raw,value=${{ needs.analyze-commit.outputs.release_type }}-${{ github.sha }}
            type=ref,event=branch
          labels: |
            org.opencontainers.image.version=${{ needs.analyze-commit.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.title=KoamiStarterKit
            org.opencontainers.image.description=Modern Laravel 12 starter kit with Vue 3, Inertia.js, and Tailwind CSS
            org.opencontainers.image.vendor=Koamishin

      - name: Build and push Docker image
        if: steps.check_docker.outputs.skip != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          build-args: |
            APP_NAME=LaravelApp
            APP_ENV=production
            APP_DEBUG=false
            APP_URL=http://localhost

  create-release:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push]
    if: needs.analyze-commit.outputs.should_release == 'true' && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ needs.analyze-commit.outputs.version }}"
          TAG="${{ needs.analyze-commit.outputs.tag }}"
          RELEASE_TYPE="${{ needs.analyze-commit.outputs.release_type }}"
          COMMIT_MSG="${{ needs.analyze-commit.outputs.commit_message }}"

          # Get commits since last tag (if any)
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${LAST_TAG}..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          fi

          cat > RELEASE_NOTES.md << EOF
          # KoamiStarterKit ${TAG} (Pre-release)

          ðŸš§ **Channel:** Develop / Rolling pre-release
          ðŸš€ **Release Type:** ${RELEASE_TYPE^}
          ðŸ“¦ **Version:** ${VERSION}
          ðŸ³ **Docker Image:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}
          ðŸ³ **Docker Alias:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest

          ## ðŸ“‹ Changes
          ${CHANGELOG}

          ## ðŸŽ¯ Latest Commit
          ${COMMIT_MSG}

          ## ðŸš€ Quick Start
          \`\`\`bash
          composer create-project koamishin/koamistarterkit my-project
          cd my-project
          composer run dev
          \`\`\`

          ## ðŸ³ Docker Deployment
          \`\`\`bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}

          # Or pull the rolling develop alias
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest
          \`\`\`

          ---
          ðŸ¤– *Auto-generated pre-release from commit ${{ github.sha }}*
          ðŸ“Š *Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}*
          EOF

      - name: Create Git tag (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          TAG="${{ needs.analyze-commit.outputs.tag }}"

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists; skipping creation."
            exit 0
          fi

          git tag -a "$TAG" -m "Pre-release $TAG"
          git push origin "$TAG"

      - name: Create GitHub Pre-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.analyze-commit.outputs.tag }}
          name: KoamiStarterKit ${{ needs.analyze-commit.outputs.tag }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: true
          files: |
            version.json
          generate_release_notes: false

  update-composer-version:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push, create-release]
    if: always() && needs.analyze-commit.result == 'success' && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped') && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update composer.json version
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ needs.analyze-commit.outputs.version }}"
          TAG="${{ needs.analyze-commit.outputs.tag }}"
          RELEASE_TYPE="${{ needs.analyze-commit.outputs.release_type }}"
          COMMIT_MSG="${{ needs.analyze-commit.outputs.commit_message }}"

          # Get previous version from composer.json
          PREVIOUS_VERSION="1.0.0"
          if [ -f "composer.json" ]; then
            PREVIOUS_VERSION=$(jq -r '.version // "1.0.0"' composer.json 2>/dev/null || echo "1.0.0")
          fi

          # Update composer.json version field using jq
          jq --arg version "$VERSION" '.version = $version' composer.json > composer.json.tmp
          mv composer.json.tmp composer.json

          # Create version.json for release artifacts (not committed to repo)
          cat > version.json << EOF
          {
            "version": "${VERSION}",
            "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "build_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "release_type": "${RELEASE_TYPE}",
            "changelog": {
              "current": "Version ${VERSION} - ${COMMIT_MSG}",
              "previous": "${PREVIOUS_VERSION}"
            },
            "metadata": {
              "author": "${{ github.actor }}",
              "workflow": "${{ github.workflow }}",
              "repository": "${{ github.repository }}"
            }
          }
          EOF

          # Commit only composer.json (version.json is just for release artifacts)
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add composer.json
          git diff --staged --quiet || git commit -m "chore: bump version to ${VERSION} [skip ci]"
          git push

  notify:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push, create-release, update-composer-version, optimize_ci]
    if: always() && needs.optimize_ci.outputs.skip == 'false'
    env:
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: Send notification
        shell: bash
        run: |
          echo "ðŸ“¢ Auto Pre-release Summary"
          echo "=========================="

          echo "ðŸ“¦ Version: ${{ needs.analyze-commit.outputs.version }}"
          echo "ðŸ·ï¸  Tag: ${{ needs.analyze-commit.outputs.tag }}"
          echo "ðŸŽ¯ Type: ${{ needs.analyze-commit.outputs.release_type }}"
          echo "ðŸ³ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.analyze-commit.outputs.tag }}"
          echo "ðŸ³ Alias: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest"
          echo "ðŸ‘¤ Author: ${{ github.actor }}"
          echo "ðŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "ðŸ“ Commit: ${{ needs.analyze-commit.outputs.commit_message }}"

          echo "ðŸ“Š Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "ðŸŽ‰ Pre-release: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze-commit.outputs.tag }}"

      - name: Send Discord notification
        if: ${{ env.DISCORD_WEBHOOK_URL != '' }}
        env:
          BUILD_RESULT: ${{ needs.build-and-push.result }}
          RELEASE_RESULT: ${{ needs.create-release.result }}
          VERSION_RESULT: ${{ needs.update-composer-version.result }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "$DISCORD_WEBHOOK_URL" ]; then
            echo "No Discord webhook configured; skipping notification"
            exit 0
          fi

          status_icon() {
            case "$1" in
              success) echo "âœ…" ;;
              skipped) echo "â­ï¸" ;;
              cancelled) echo "âšª" ;;
              *) echo "âŒ" ;;
            esac
          }

          BUILD_ICON=$(status_icon "$BUILD_RESULT")
          RELEASE_ICON=$(status_icon "$RELEASE_RESULT")
          VERSION_ICON=$(status_icon "$VERSION_RESULT")

          if [ "$BUILD_RESULT" = "success" ]; then
            COLOR=5763719
            SUMMARY="Build succeeded"
          else
            COLOR=15548997
            SUMMARY="Build failed"
          fi

          RECENT_CHANGES=$(git log -5 --pretty=format:"- %s (%an)" HEAD 2>/dev/null || true)
          if [ -z "${RECENT_CHANGES:-}" ]; then
            RECENT_CHANGES="(No additional commits detected)"
          fi

          CONTRIBUTORS=$(git log -20 --pretty=format:"%an" HEAD 2>/dev/null | awk '!seen[$0]++' | head -n 10 | paste -sd ', ' - 2>/dev/null || true)
          if [ -z "${CONTRIBUTORS:-}" ]; then
            CONTRIBUTORS="${{ github.actor }}"
          fi

          RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze-commit.outputs.tag }}"

          PAYLOAD=$(jq -n \
            --arg summary "$SUMMARY" \
            --arg build "$BUILD_ICON Build: $BUILD_RESULT" \
            --arg release "$RELEASE_ICON Release: $RELEASE_RESULT" \
            --arg version "$VERSION_ICON Version File: $VERSION_RESULT" \
            --arg versionLabel "${{ needs.analyze-commit.outputs.version }}" \
            --arg tag "${{ needs.analyze-commit.outputs.tag }}" \
            --arg type "${{ needs.analyze-commit.outputs.release_type }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg actor "${{ github.actor }}" \
            --arg commit "${{ needs.analyze-commit.outputs.commit_message }}" \
            --arg buildUrl "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg docker "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.analyze-commit.outputs.tag }}" \
            --arg dockerAlias "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest" \
            --arg releaseUrl "$RELEASE_URL" \
            --arg changes "$RECENT_CHANGES" \
            --arg contributors "$CONTRIBUTORS" \
            --argjson color "$COLOR" \
            '{
              "username": "KoamiStarterKit Bot",
              "embeds": [
                {
                  "title": "Develop Pre-release â€¢ \($summary)",
                  "color": $color,
                  "description": "**Version:** \($versionLabel)\n**Tag:** \($tag)\n**Type:** \($type)",
                  "fields": [
                    { "name": "Pipeline", "value": $buildUrl, "inline": false },
                    { "name": "Docker Image", "value": $docker, "inline": false },
                    { "name": "Docker Alias", "value": $dockerAlias, "inline": false },
                    { "name": "Build Stage", "value": $build, "inline": true },
                    { "name": "Release Stage", "value": $release, "inline": true },
                    { "name": "Version File", "value": $version, "inline": true },
                    { "name": "Branch", "value": $branch, "inline": true },
                    { "name": "Actor", "value": $actor, "inline": true },
                    { "name": "Commit", "value": $commit, "inline": false },
                    { "name": "Latest Changes", "value": $changes, "inline": false },
                    { "name": "Contributors", "value": $contributors, "inline": false }
                  ],
                  "footer": {
                    "text": "Pre-release details - \($releaseUrl)"
                  },
                  "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
                }
              ]
            }')

          curl -X POST \
            "$DISCORD_WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d "$PAYLOAD"
